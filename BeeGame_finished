from cmu_graphics import *
from PIL import Image
import random, time
import math

class Bee:
    def __init__(self):
        #Load the frame
        
        #Load the bee gif
        myGif = Image.open('./bee1.gif')
        self.spriteList = []
        self.spriteListTrans = []
        for frame in range(myGif.n_frames):  #For every frame index...
            #Seek to the frame, convert it, add it to our sprite list
            myGif.seek(frame)
            fr = myGif.resize((myGif.size[0]//10, myGif.size[1]//10))
            fr2 = fr.transpose(Image.FLIP_LEFT_RIGHT)
            fr = CMUImage(fr)
            fr2 = CMUImage(fr2)
            self.spriteList.append(fr)
            self.spriteListTrans.append(fr2)

        ##Fix for broken transparency on frame 0
        self.spriteList.pop(0)

        #Set sprite counters
        self.stepCounter = 0
        self.spriteCounter = 0

        self.spriteListTrans.pop(0)

        

        #Set initial position, velocity, acceleration
        self.x, self.y = 100, 100
        self.dy = 0
        self.ddy = .1
        self.speed = 0
        self.donotMove = False

    def draw(self,app):
        #Draw current bee sprite
        if app.mousePosX > self.x:
        # Bee is moving right, so don't flip the image
            drawImage(self.spriteList[self.spriteCounter], 
                    self.x, self.y, align = 'center')
        else:
            # Bee is moving left, so flip the image horizontally
            drawImage(self.spriteListTrans[self.spriteCounter], self.x, self.y, align='center')
        # if app.pollinated != False:
        #     drawCircle(self.x-18, self.y+45, 12, fill = 'black', opacity = 75)
        
    def doStep(self,app):
        # Calculate the distance to the mouse position
        dist = math.sqrt((self.x - app.mousePosX)**2 + (self.y - app.mousePosY)**2)

        # Set the bee's speed to be proportional to the distance
        self.speed += dist / 10000

        # Limit the bee's speed to a maximum of 10
        if self.speed > 10:
            self.speed = 10

        # Calculate the direction to the mouse position
        dx = app.mousePosX - self.x
        dy = app.mousePosY - self.y

        # Normalize the direction vector
        # length = math.sqrt(dx**2 + dy**2)
        if dist > 5:
            dx /= dist
            dy /= dist
        #     self.donotMove = False
        # else:
        #     self.donotMove = True


        # Update the bee's position
        self.x += dx * self.speed
        self.y += dy * self.speed


        # Increase the speed of the bee's animation as its speed increases
        if self.speed < 1:
            stepsPerSprite = 10*2
        elif self.speed < 2:
            stepsPerSprite = 8
        elif self.speed < 4:
            stepsPerSprite = 6/2
        else:
            stepsPerSprite = 4/2
        self.stepCounter += 1
        if self.stepCounter >= stepsPerSprite: #Update the sprite every Nth call
            self.spriteCounter = (self.spriteCounter + 1) % len(self.spriteList)
            self.stepCounter = 0

        
        



    def isColliding(self, flowers,app):
        for flower in flowers:
            if ((self.x - flower.x)**2 + (self.y - flower.y)**2)**0.5 < flower.r:
                flower.pollinated = True
                #return True
            return False


#-------------------------------------------------------------------
#The helperBee is clumsy
class helperBee:
    def __init__(self,app):
        #Load the bee gif
        myGif = Image.open('./bee2.gif')
        self.spriteList = []
        self.spriteListTrans = []
        for frame in range(myGif.n_frames):  #For every frame index...
            #Seek to the frame, convert it, add it to our sprite list
            myGif.seek(frame)
            fr = myGif.resize((myGif.size[0]//10, myGif.size[1]//10))
            fr2 = fr.transpose(Image.FLIP_LEFT_RIGHT)
            fr = CMUImage(fr)
            fr2 = CMUImage(fr2)
            self.spriteList.append(fr)
            self.spriteListTrans.append(fr2)

        ##Fix for broken transparency on frame 0
        self.spriteList.pop(0)
       

        #Set sprite counters
        self.stepCounter = 0
        self.spriteCounter = 0
        self.spriteListTrans.pop(0)
        #Set initial position, velocity, acceleration
        self.x, self.y = app.width//2,app.height//2
        self.dy = random.randrange(-5,5)
        self.dx = random.randrange(-5,5)

        self.ddy = .1
        self.speed = 0
        self.closestUnpoll = None
        self.closestFlower = None
        self.turn = False
    
        
    
        
    def doStep(self, app):
        # if len(app.pollen.colorList) <6:
        if self.closestFlower is None:
            # Find nearest unpollinated flower
            minDist = float('inf')
            self.closestFlower = None
            
            for flower in app.flowers:
                if flower.needToDrawByHelper == False and flower.needToDraw == False and flower.needToDrawByHelper2 == False: 
                    dist = ((self.x - flower.x) ** 2 + (self.y - flower.y) ** 2) ** 0.5
                    if dist < minDist:
                        minDist = dist
                        self.closestFlower = flower
                        dx = self.closestFlower.x - self.x
                        dy = self.closestFlower.y - self.y

                        # self.x += self.dx
                        # self.y += self.dy
                            

                
            # Move randomly
            # if self.closestFlower is None:
            self.x += random.randint(-5, 5)
            self.y += random.randint(-5, 5)
                        
                

        elif self.closestFlower != None:
            # Move towards target flower
            dx = self.closestFlower.x - self.x
            dy = self.closestFlower.y - self.y
            if dx>=0:
                self.turn = True
            else:
                self.turn = False
            
            distance = (dx ** 2 + dy ** 2) ** 0.5
            if distance > 0:
                dx /= distance
                dy /= distance
                self.x += dx*self.speed
                self.y += dy*self.speed
            if self.closestFlower.needToDraw == True or self.closestFlower.needToDrawByHelper == True or self.closestFlower.needToDrawByHelper2 == True:
                self.closestFlower = None
                # self.x, self.y = app.width//2,app.height//2
            elif self.closestFlower.y + self.closestFlower.r >= app.height:
                self.closestFlower = None
            elif self.closestFlower.x + self.closestFlower.r >= app.width or self.closestFlower.x - self.closestFlower.r <= 0:
                self.closestFlower = None
            # Limit the bee's speed to a maximum of 5
            self.speed = (self.dx ** 2 + self.dy ** 2) ** 0.5
            if self.speed > 10:
                self.speed = 10
        # else: 
        if self.closestUnpoll is None:
            # Find nearest unpollinated flower
            minDist = float('inf')
            self.closestUnpoll = None
            
            for unpoll in app.unpolls:
                if unpoll.needToDrawByHelper == False and unpoll.needToDraw == False and unpoll.needToDrawByHelper2 == False:
                    dist = ((self.x - unpoll.x) ** 2 + (self.y - unpoll.y) ** 2) ** 0.5
                    # if dist < minDist:
                    #     minDist = dist
                    self.closestUnpoll = unpoll
                    dx = self.closestUnpoll.x - self.x
                    dy = self.closestUnpoll.y - self.y

                    # self.x += self.dx
                    # self.y += self.dy
                            

                
            # Move randomly
            # if self.closestUnpoll is None:
            self.x += random.randint(-5, 5)
            self.y += random.randint(-5, 5)
                        
                

        elif self.closestUnpoll != None and self.closestUnpoll.color in app.pollen.colorList:
            # Move towards target flower
            dx = self.closestUnpoll.x - self.x
            dy = self.closestUnpoll.y - self.y
            if dx>=0:
                self.turn = True
            else:
                self.turn = False
            
            distance = (dx ** 2 + dy ** 2) ** 0.5
            if distance > 0:
                dx /= distance
                dy /= distance
                self.x += dx*self.speed
                self.y += dy*self.speed
            if self.closestUnpoll.needToDraw == True or self.closestUnpoll.needToDrawByHelper == True or self.closestUnpoll.needToDrawByHelper2 == True:
                self.closestUnpoll = None
                # self.x, self.y = app.width//2,app.height//2
            elif self.closestUnpoll.y + self.closestUnpoll.r >= app.height:
                self.closestUnpoll = None
            elif self.closestUnpoll.x + self.closestUnpoll.r >= app.width or self.closestUnpoll.x - self.closestUnpoll.r <= 0:
                self.closestUnpoll = None
            # Limit the bee's speed to a maximum of 5
            self.speed = (self.dx ** 2 + self.dy ** 2) ** 0.5
            if self.speed > 10:
                self.speed = 10

        # self.x += self.dx
        # self.y += self.dy
        
            
        # Update bee position and velocity
        if self.x <= app.width//2 or self.x >= app.width:
            self.dx = -1 * self.dx
            self.x = max(0, min(self.x, app.width)) + self.dx
        if self.y <= 0 or self.y >= app.height:
            self.dy = -1 * self.dy
            self.y = max(0, min(self.y, app.height)) + self.dy

        # Update bee sprite
        self.stepCounter += 1
        if self.stepCounter >= 2000:  # Update the sprite every 10th call
            self.spriteCounter = (self.spriteCounter + 1) % len(self.spriteList)
            self.stepCounter = 0

        #Update position and velocity
    
    def draw(self,app):
            #Draw current bee sprite
            if self.turn:
                drawImage(self.spriteList[self.spriteCounter], 
                        self.x, self.y, align = 'center')
            else:
                drawImage(self.spriteListTrans[self.spriteCounter], 
                        self.x, self.y, align = 'center')
            


    def isColliding(self, flowers,app):
        for flower in flowers:
            if ((self.x - flower.x)**2 + (self.y - flower.y)**2)**0.5 < flower.r:
                flower.pollinated = True
                return True
            return False
#-------------------------------------------------------------------
class helperBee2:
    def __init__(self,app):
        #Load the bee gif
        myGif = Image.open('./bee2.gif')
        self.spriteList = []
        self.spriteListTrans = []
        for frame in range(myGif.n_frames):  #For every frame index...
            #Seek to the frame, convert it, add it to our sprite list
            myGif.seek(frame)
            fr = myGif.resize((myGif.size[0]//10, myGif.size[1]//10))
            fr2 = fr.transpose(Image.FLIP_LEFT_RIGHT)
            fr = CMUImage(fr)
            fr2 = CMUImage(fr2)
            self.spriteList.append(fr)
            self.spriteListTrans.append(fr2)

        ##Fix for broken transparency on frame 0
        self.spriteList.pop(0)
       

        #Set sprite counters
        self.stepCounter = 0
        self.spriteCounter = 0
        self.spriteListTrans.pop(0)
        #Set initial position, velocity, acceleration
        self.x, self.y = app.width//4,app.height//4
        self.dy = random.randrange(-5,5)
        self.dx = random.randrange(-5,5)

        self.ddy = .1
        self.speed = 0
        self.closestUnpoll = None
        self.closestFlower = None
        self.turn = False
    
        
    
        
    def doStep(self, app):
        # if len(app.pollen.colorList) <6:
        if self.closestFlower is None:
            # Find nearest unpollinated flower
            minDist = float('inf')
            self.closestFlower = None
            
            for flower in app.flowers:
                if flower.needToDrawByHelper == False and flower.needToDraw == False and flower.needToDrawByHelper2 == False:
                    dist = ((self.x - flower.x) ** 2 + (self.y - flower.y) ** 2) ** 0.5
                    if dist < minDist:
                        minDist = dist
                        self.closestFlower = flower
                        dx = self.closestFlower.x - self.x
                        dy = self.closestFlower.y - self.y

                        # self.x += self.dx
                        # self.y += self.dy
                            

                
            # Move randomly
            # if self.closestFlower is None:
            self.x += random.randint(-5, 5)
            self.y += random.randint(-5, 5)
                        
                

        elif self.closestFlower != None:
            # Move towards target flower
            dx = self.closestFlower.x - self.x
            dy = self.closestFlower.y - self.y
            if dx>=0:
                self.turn = True
            else:
                self.turn = False
            
            distance = (dx ** 2 + dy ** 2) ** 0.5
            if distance > 0:
                dx /= distance
                dy /= distance
                self.x += dx*self.speed
                self.y += dy*self.speed
            if self.closestFlower.needToDraw == True or self.closestFlower.needToDrawByHelper == True or self.closestFlower.needToDrawByHelper2 == True:
                self.closestFlower = None
                # self.x, self.y = app.width//2,app.height//2
            elif self.closestFlower.y + self.closestFlower.r >= app.height:
                self.closestFlower = None
            elif self.closestFlower.x + self.closestFlower.r >= app.width or self.closestFlower.x - self.closestFlower.r <= 0:
                self.closestFlower = None
            # Limit the bee's speed to a maximum of 5
            self.speed = (self.dx ** 2 + self.dy ** 2) ** 0.5
            if self.speed > 10:
                self.speed = 10
        # else: 
        if self.closestUnpoll is None:
            # Find nearest unpollinated flower
            minDist = float('inf')
            self.closestUnpoll = None
            
            for unpoll in app.unpolls:
                if unpoll.needToDrawByHelper == False and unpoll.needToDraw == False and unpoll.needToDrawByHelper2 == False:
                    dist = ((self.x - unpoll.x) ** 2 + (self.y - unpoll.y) ** 2) ** 0.5
                    # if dist < minDist:
                    #     minDist = dist
                    self.closestUnpoll = unpoll
                    dx = self.closestUnpoll.x - self.x
                    dy = self.closestUnpoll.y - self.y

                    # self.x += self.dx
                    # self.y += self.dy
                            

                
            # Move randomly
            # if self.closestUnpoll is None:
            self.x += random.randint(-5, 5)
            self.y += random.randint(-5, 5)
                        
                

        elif self.closestUnpoll != None and self.closestUnpoll.color in app.pollen.colorList:
            # Move towards target flower
            dx = self.closestUnpoll.x - self.x
            dy = self.closestUnpoll.y - self.y
            if dx>=0:
                self.turn = True
            else:
                self.turn = False
            
            distance = (dx ** 2 + dy ** 2) ** 0.5
            if distance > 0:
                dx /= distance
                dy /= distance
                self.x += dx*self.speed
                self.y += dy*self.speed
            if self.closestUnpoll.needToDraw == True or self.closestUnpoll.needToDrawByHelper == True or self.closestUnpoll.needToDrawByHelper2 == True:
                self.closestUnpoll = None
                # self.x, self.y = app.width//2,app.height//2
            elif self.closestUnpoll.y + self.closestUnpoll.r >= app.height:
                self.closestUnpoll = None
            elif self.closestUnpoll.x + self.closestUnpoll.r >= app.width or self.closestUnpoll.x - self.closestUnpoll.r <= 0:
                self.closestUnpoll = None
            # Limit the bee's speed to a maximum of 5
            self.speed = (self.dx ** 2 + self.dy ** 2) ** 0.5
            if self.speed > 10:
                self.speed = 10

        # self.x += self.dx
        # self.y += self.dy
            
        # Update bee position and velocity
        if self.x <= 0 or self.x >= app.width//2:
            self.dx = -1 * self.dx
            self.x = max(0, min(self.x, app.width)) + self.dx
        if self.y <= 0 or self.y >= app.height:
            self.dy = -1 * self.dy
            self.y = max(0, min(self.y, app.height)) + self.dy

        # Update bee sprite
        self.stepCounter += 1
        if self.stepCounter >= 2000:  # Update the sprite every 10th call
            self.spriteCounter = (self.spriteCounter + 1) % len(self.spriteList)
            self.stepCounter = 0

        #Update position and velocity
    
    def draw(self,app):
            #Draw current bee sprite
            if self.turn:
                drawImage(self.spriteList[self.spriteCounter], 
                        self.x, self.y, align = 'center')
            else:
                drawImage(self.spriteListTrans[self.spriteCounter], 
                        self.x, self.y, align = 'center')
            


    def isColliding(self, flowers,app):
        for flower in flowers:
            if ((self.x - flower.x)**2 + (self.y - flower.y)**2)**0.5 < flower.r:
                flower.pollinated = True
                return True
            return False
#-------------------------------------------------------------------
class Flower:
    def __init__(self, app):
        self.x = random.randrange(30,app.width-30)
        self.y = 0
        self.dy = random.randrange(2, 4)
        self.dx = random.randrange(-3, 3)
        
        self.r = random.randrange(10, 35)
        self.color = random.choice(['red', 'yellow', 'blue'])
        self.max_size = self.r * 1.5
        self.growth_rate = 0.2
        self.pollinated = False
        self.needToDraw = False
        self.needToDrawByHelper = False
        self.needToDrawByHelper2 = False
        self.pollinateCount = 0
        self.needToDrawAgain = False
        self.pollenDraw = False
        self.offset = random.uniform(0, 2*math.pi)
        self.added = False

    def doStep(self,app):
        self.y += self.dy//2
        self.x += self.dx
        # Add sinusoidal movement to the y-coordinate
        amplitude = 5
        frequency = 0.03
        self.x = amplitude*math.sin(frequency*self.y + self.offset) + self.x
        
        if self.x <= 0:
            self.x = 0
            self.dx = -1*self.dx
        elif self.x >= app.width:
            self.x = app.width
            self.dx = -1*self.dx
        if self.r <= self.max_size:
            self.r += self.growth_rate
        #self.x += random.randrange(-2,2) * self.dx

    def draw(self,app):
        
        if self.needToDraw == False and self.needToDrawAgain == False and self.needToDrawByHelper == False and self.needToDrawByHelper2 == False:
            drawCircle(self.x, self.y, self.r, fill = self.color, opacity = 75)
        elif self.needToDraw == False and self.needToDrawAgain == True and self.needToDrawByHelper == False and self.needToDrawByHelper2 == False:
            drawCircle(self.x, self.y, self.r-5, fill = self.color, opacity = 75)
            drawCircle(self.x, self.y, (self.r-5)//2, fill = 'white', opacity = 75)
            drawCircle(self.x, self.y, (self.r-5)//4, fill = self.color, opacity = 75)
        elif self.needToDraw == True or self.needToDrawByHelper==True or self.needToDrawByHelper2==True:
            drawCircle(self.x, self.y, self.r-5, fill = self.color, opacity = 75)
            drawCircle(self.x, self.y, (self.r-5)//2, fill = 'white', opacity = 75)
            drawCircle(self.x, self.y, (self.r-5)//4, fill = self.color, opacity = 75)

    def offLeftEdge(self):
            return self.x < 0 - self.r
    
    def offBottomEdge(self, app):
        return self.y+ self.r > app.height
    def comesOut(self, app):
        return self.y >0 and self.y < app.height
    
    def pollination(self, bee):
        
        if ((self.x - bee.x)**2 + (self.y - bee.y)**2)**0.5 < self.r:
                
            return True
            
        else:
            
            return False
        
#-------------------------------------------------------------------
class UnpoFlow:
    def __init__(self, app):
        self.x = random.randrange(50, app.width-50)
        self.y = 0
        self.dy = random.randrange(2, 4)
        self.dx = random.randrange(-1, 1)
        
        self.r = random.randrange(15, 30)
        self.color = random.choice(['red', 'yellow', 'blue'])
        self.pollinated = False
        self.needToDraw = False
        self.needToDrawByHelper = False
        self.needToDrawByHelper2 = False
        self.pollinateCount = 0
        self.needToDrawAgain = False
        self.pollenDraw = False
        self.alreadyPollinated = False
        self.max_size = self.r * 1.5
        self.growth_rate = 0.25
        self.offset = random.uniform(0, 2*math.pi)

    def doStep(self,app):
        self.y += self.dy//2
        self.x += self.dx
        # Add sinusoidal movement to the y-coordinate
        amplitude = 5
        frequency = 0.03
        self.x = amplitude*math.sin(frequency*self.y + self.offset) + self.x
        if self.pollinated== True and self.r <= self.max_size:
        
            self.r += self.growth_rate
        if self.x <= 0:
            self.x = 0 
            self.dx = -1*self.dx
            
        elif self.x >= app.width:
            self.x = app.width
            self.dx = -1*self.dx
            
        

        

    def draw(self,app):
        if self.pollinated == False and self.needToDraw == False and self.needToDrawByHelper == False and self.needToDrawByHelper2 == False:
            drawCircle(self.x, self.y, self.r-5, fill = self.color, opacity = 75)
            drawCircle(self.x, self.y, (self.r-5)//2, fill = 'black', opacity = 75)
        # drawCircle(self.x, self.y, (self.r-5)//4, fill = self.color, opacity = 75)
        elif self.needToDraw == True or self.needToDrawByHelper == True or self.needToDrawByHelper2 == False:
            drawCircle(self.x, self.y, self.r-5, fill = self.color, opacity = 75)
            drawCircle(self.x, self.y, (self.r-5)//2, fill = 'purple', opacity = 75)
        

    # def offLeftEdge(self):
    #         return self.x < 0 - self.r
    
    def offBottomEdge(self, app):
        return self.y + self.r > app.height
    def comesOut(self, app):
        return self.y >0 and self.y < app.height
    

    def pollination(self, bee,pollen,app):
        #a pollen list color or a bee list color
        for color in pollen.colorList:
            if color == self.color:
                
                index = pollen.colorList.index(self.color)
                
        
                if (((self.x - bee.x)**2 + (self.y - bee.y)**2)**0.5 < self.r+5) and self.alreadyPollinated == False:
                    
                    if (self.color in pollen.colorList) and (self.color not in pollen.beeColor) and (self.color not in pollen.helperBeeColor2) and (self.color in pollen.helperBeeColor):
                        pollen.colorList.pop(index)
                        index2 = len(pollen.helperBeeColor) - pollen.helperBeeColor[::-1].index(self.color) - 1
                        app.score +=1
                        
                        pollen.helperBeeColor.pop(index2)
                    elif (self.color in pollen.colorList) and (self.color not in pollen.helperBeeColor) and (self.color not in pollen.helperBeeColor2) and (self.color in pollen.beeColor):
                        
                        index2 = len(pollen.beeColor) - pollen.beeColor[::-1].index(self.color) - 1
                        
                        pollen.beeColor.pop(index2)
                        pollen.colorList.pop(index)
                        app.score +=1
                    elif (self.color in pollen.colorList) and (self.color not in pollen.beeColor) and (self.color not in pollen.helperBeeColor) and (self.color in pollen.helperBeeColor2):
                        index2 = len(pollen.helperBeeColor2) - pollen.helperBeeColor2[::-1].index(self.color) - 1
                        
                        pollen.helperBeeColor2.pop(index2)
                        pollen.colorList.pop(index)
                        app.score +=1
                    
                    else:
                        pollen.colorList.pop(index)
                        app.score +=1

                    self.alreadyPollinated = True
                    self.pollinated = True
                
                    return True
                
                return False
    
            
        
        
#-------------------------------------------------------------------
class Pollen:
    def __init__(self):
        self.r = 12
        self.counter = 0
        self.colorList = []
        self.beeColor = []
        self.needToDraw = False
        self.needToDrawByHelper = False
        self.alreadyPop = False
        self.helperBeeColor = []
        self.helperBeeColor2 = []


    def draw(self,bee,flowers,helperBee, helperBee2):
        
            
        for flower in flowers:
            if flower.needToDraw == True and flower.needToDrawAgain == False:
                #color = random.choice(['red', 'yellow', 'blue'])
                self.colorList.append(flower.color)
                self.beeColor.append(flower.color)
                
                
                self.counter += 1
                flower.needToDraw = False
                flower.needToDrawAgain = True
                self.needToDraw = True
            
            
            for i in range(len(self.colorList)):
                
                if i <=5:
                    drawCircle(100+20*i, 50, 20, fill = self.colorList[i], opacity = 75)   

                if i > 5:
                    self.colorList.pop(0)
            
            for j in range(len(self.beeColor)):
                
                if j <=1:
                    drawCircle(bee.x-10+15*j, bee.y+45, self.r, fill = self.beeColor[j], opacity = 75)
                

                if j > 1:
                    self.beeColor.pop(0)
                    
        for flower in flowers:
            if flower.needToDrawByHelper == True and flower.needToDrawAgain == False:
                #color = random.choice(['red', 'yellow', 'blue'])
                self.colorList.append(flower.color)
                self.helperBeeColor.append(flower.color)
                
                self.counter += 1
                flower.needToDraw = False
                flower.needToDrawAgain = True
                self.needToDraw = True
            
            
            for i in range(len(self.colorList)):
                
                if i <=5:
                    drawCircle(100+20*i, 50, 20, fill = self.colorList[i], opacity = 75)   

                if i > 5:
                    self.colorList.pop(0)
            
            for j in range(len(self.helperBeeColor)):
                
                if j <=1:
                    
                    drawCircle(helperBee.x-10+15*j, helperBee.y+25, self.r//2, fill = self.helperBeeColor[j], opacity = 75)
                

                if j > 1:
                    self.helperBeeColor.pop(0)

        for flower in flowers:
            if flower.needToDrawByHelper2 == True and flower.needToDrawAgain == False:
                #color = random.choice(['red', 'yellow', 'blue'])
                self.colorList.append(flower.color)
                self.helperBeeColor2.append(flower.color)
                
                self.counter += 1
                flower.needToDraw = False
                flower.needToDrawAgain = True
                self.needToDraw = True
            
            
            for i in range(len(self.colorList)):
                
                if i <=5:
                    drawCircle(100+20*i, 50, 20, fill = self.colorList[i], opacity = 75)   

                if i > 5:
                    self.colorList.pop(0)
            
            for j in range(len(self.helperBeeColor2)):
                
                if j <=1:
                    
                    drawCircle(helperBee2.x-10+15*j, helperBee2.y+25, self.r//2, fill = self.helperBeeColor2[j], opacity = 75)
                

                if j > 1:
                    self.helperBeeColor2.pop(0)
            

        
#-------------------------------------------------------------------
def onAppStart(app):
    game_restart(app)

def game_restart(app):
    app.gameOver = False
    app.paused = False
    app.stepsPerSecond = 40
    app.bee = Bee()
    app.helperBee = helperBee(app)
    app.helperBee2 = helperBee2(app)
    app.unpolls = []
    app.flowers = []
    app.pollinatedFlowers = []
    app.lastFlowerTime = time.time()
    app.lastunpollTime = time.time()
    app.score = 0
    app.label = ''
    app.pollinateCount = 0
    app.pollinated = False
    app.pollinated1 = False
    app.helperShow = False
    app.helperShow2 = False
    app.needToDraw = False
    app.needToDrawByHelper = False
    app.needToDrawByHelper2 = False
    app.pollen = Pollen()
    app.mousePosX = 100
    app.mousePosY = 100
    app.url = 'https://as2.ftcdn.net/v2/jpg/02/90/87/69/1000_F_290876973_mCltaYqk3G8FWiszXxrCwzUL5wmbGHSt.jpg'
    app.score = 0
    
    
    
def game_onStep(app):
    if app.paused == False and app.gameOver == False:
    
        game_takeStep(app)
        
def game_onKeyPress(app):
    if app.key =='p':
        app.paused = not app.paused
def game_takeStep(app):
    dist = math.sqrt((app.bee.x - app.mousePosX)**2 + (app.bee.y - app.mousePosY)**2)
    if dist > 5:
        app.bee.doStep(app)
    if app.helperShow == True:
        app.helperBee.doStep(app)
    if app.helperShow2 == True:
        app.helperBee2.doStep(app)
    i = 0

    #Update the flowers
    while i < len(app.flowers):
        flower = app.flowers[i]
        flower.doStep(app)
        if flower.offBottomEdge(app):
            app.flowers.pop(i)
            
            print('pop')
            app.score += 1
            # if app.score >= 1 and app.score<=10:
            #     app.helperShow = True
        
        if flower.pollination(app.bee):
            # app.pollinateCount += 0.05
            # totalCount = int(app.pollinateCount//1)
            flower.pollinateCount += 0.1
            totalCount = int(flower.pollinateCount//1)
            if totalCount >=1:
                
                flower.needToDraw = True
                #app.pollinated = True

            app.pollinateCount += totalCount
            #app.flowerPollinated = True
            
            app.label = 'You need some time to get pollen'
            

        if flower.pollination(app.helperBee):
            # app.pollinateCount += 0.05
            # totalCount = int(app.pollinateCount//1)
            flower.pollinateCount += 0.5
            totalCount = int(flower.pollinateCount//1)
            if totalCount >=1:
                totalCount = 1
                flower.needToDrawByHelper = True
                app.pollinated1 = True
            app.pollinateCount += totalCount
            #app.flowerPollinated = True
        
        if flower.pollination(app.helperBee2):
            # app.pollinateCount += 0.05
            # totalCount = int(app.pollinateCount//1)
            flower.pollinateCount += 0.5
            totalCount = int(flower.pollinateCount//1)
            if totalCount >=1:
                totalCount = 1
                flower.needToDrawByHelper2 = True
                app.pollinated1 = True
            app.pollinateCount += totalCount
            #app.flowerPollinated = True
            

        if app.bee.isColliding(app.flowers,app) or app.helperBee.isColliding(app.flowers, app) or app.helperBee2.isColliding(app.flowers, app):
            app.pollinated = True
            
            
           
        else:
            i += 1
            

    if (time.time() - app.lastFlowerTime > 2) and (len(app.flowers) < 4):
        app.flowers.append(Flower(app))
        app.lastFlowerTime = time.time()


    #update the unpollinated flowers
    j = 0
    while j < len(app.unpolls):
        
        unpoll = app.unpolls[j]
        unpoll.doStep(app)
        if unpoll.offBottomEdge(app):
            app.unpolls.pop(j)
            print('pop2')
        
        if unpoll.pollination(app.bee,app.pollen,app):
            
                
            unpoll.needToDraw = True
            
            

        if unpoll.pollination(app.helperBee,app.pollen,app):
                
            unpoll.needToDrawByHelper = True
            
        if unpoll.pollination(app.helperBee2,app.pollen,app):
                
            unpoll.needToDrawByHelper2 = True 
            
        
        else:
            j += 1
            

    if (time.time() - app.lastunpollTime > 6) and (len(app.unpolls) < 2):
        app.unpolls.append(UnpoFlow(app))
        app.lastunpollTime = time.time()

    if app.bee.y > app.height or app.bee.y < 0 or app.bee.x > app.width or app.bee.x < 0:
        app.gameOver = True

        app.label = 'Game over'
        setActiveScreen('gameOver')
  

def game_onMouseMove(app, mouseX, mouseY):
    # This is called when the user moves the mouse
    # while it is not pressed:
    if app.gameOver == False:
        app.mousePosX = mouseX
        app.mousePosY = mouseY

def game_onKeyPress(app, key):
    
    if key == 'r':
        game_restart(app)
    elif key =='p':
        app.paused = not app.paused
    elif key == 'h':
        app.helperShow = True
    elif key =='j':
        app.helperShow2 = True

    

def game_redrawAll(app):
    # #new BG of garden gif
    # myBgGif = Image.open('D:/CMU/semester2/15-112/term_project/garden.gif')
    # spriteList = []
    # for frame in range(myBgGif.n_frames):  #For every frame index...
    #     #Seek to the frame, convert it, add it to our sprite list
    #     myBgGif.seek(frame)
    #     fr = myBgGif.resize((myBgGif.size[0] * 2, myBgGif.size[1]*3))
    #     fr = fr.transpose(Image.FLIP_LEFT_RIGHT)
    #     fr = CMUImage(fr)
    #     spriteList.append(fr)

    # ##Fix for broken transparency on frame 0
    # spriteList.pop(0)

    # #Set sprite counters
    
    # spriteCounter = 0


    # #Draw current bee sprite
    # drawImage(spriteList[spriteCounter], 
    #             200, 300, align = 'center')
    #Background
    drawRect(0, 0, app.width, app.height, fill='lightGreen')
    drawLabel(app.label, 200, 10, size = 12)
    drawLabel("Press r to restart or p to pause", 200, 25, size = 12)
    #Call bee's draw method
    app.bee.draw(app)
    if app.helperShow == True:
        app.helperBee.draw(app)

    if app.helperShow2 == True:
        app.helperBee2.draw(app)

    app.pollen.draw(app.bee,app.flowers,app.helperBee, app.helperBee2)

    #Call each flower's draw method
    for flower in app.flowers:
        flower.draw(app)
    for flower in app.pollinatedFlowers:
        flower.draw(app)
    for unpoll in app.unpolls:
        unpoll.draw(app)
    
#Change width and height to suit your needs    
# runApp(width=800, height=600)
def welcome_redrawAll(app):
    drawImage(app.url,0,0)
    drawLabel("Welcome to The Game", app.width/2, app.height/2, size = 24,fill='fireBrick')
    
    drawCircle(app.width//2, app.height//2+100,50,fill='cyan',border='midnightBlue',borderWidth=2)
    drawCircle(app.width//2, app.height//2+100,35,fill='cornflowerBlue',opacity = 75, border='midnightBlue',borderWidth=2)
    drawLabel("Start", app.width//2, app.height//2+100, size = 24,fill='black')


    #instruction button
    drawCircle(app.width-100, app.height-100,50,fill='coral', border='black', borderWidth=2)
    drawCircle(app.width-100, app.height-100,35,fill='lightSalmon',opacity = 75, border='midnightBlue',borderWidth=2)
      
    drawLabel("instruction", app.width-100, app.height-100, size = 20,fill='black')
    



def welcome_onKeyPress(app, key):
    if key == 'space':
        setActiveScreen('game')
def welcome_onMousePress(app, mouseX, mouseY):
    # This is called when the user presses the mouse.
    # For this example, we just have to update the
    # model to move the dot to this location:
    if ((mouseX-app.width//2)**2 + (mouseY-(app.height+100)//2)**2)**0.5 <= 50:
        setActiveScreen('game')
    elif ((mouseX-app.width+100)**2 + (mouseY-app.height+100)**2)**0.5 <= 50:
        setActiveScreen('instruction')
    
#---------------------------------------------------
#Game Over screen
def gameOver_redrawAll(app):
    drawImage(app.url,0,0)
    drawLabel("Your Game is Over.", app.width/2, app.height/2, size = 24,fill='black')
    drawLabel("Good Game", app.width/2, 100+app.height/2, size = 20,fill='white')
    drawLabel("Press R to restart", app.width/2, 75+app.height/2, size = 24,fill='darkRed')
    drawLabel(f'Your final score is {app.score} !', app.width/2, 35+app.height/2, size = 24,fill='maroon')
    drawCircle(200,300,50,fill='cyan',border='midnightBlue',borderWidth=2)
    drawCircle(200,300,35,fill='cornflowerBlue',opacity = 75, border='midnightBlue',borderWidth=2)
    drawLabel("Start", 200, 300, size = 24,fill='black')
    



def gameOver_onKeyPress(app, key):
    if key == 'r':
        setActiveScreen('game')
        game_restart(app)
def gameOver_onMousePress(app, mouseX, mouseY):
    # This is called when the user presses the mouse.
    # For this example, we just have to update the
    # model to move the dot to this location:
    if ((mouseX-200)**2 + (mouseY-200)**2)**0.5 <= 50:
        setActiveScreen('game')
        game_restart(app)

#---------------------------------------------------
#Instruction screen
def instruction_redrawAll(app):
    drawImage(app.url,0,0)
    
    drawCircle(200,300,50,fill='cyan',border='midnightBlue',borderWidth=2)
    drawCircle(200,300,35,fill='cornflowerBlue',opacity = 75, border='midnightBlue',borderWidth=2)
    drawLabel("Start", 200, 300, size = 24,fill='black')
    drawImage(app.bee.spriteList[app.bee.spriteCounter], 
                    app.width*0.75, 100, align = 'center')
    drawImage(app.helperBee.spriteList[app.helperBee.spriteCounter], 
                    app.width*0.75, 150, align = 'center')
    drawCircle(app.width*0.75, 200, 25, fill = 'blue', opacity = 75)
    drawCircle(app.width*0.75, 250, 25, fill = 'blue', opacity = 75)
    drawCircle(app.width*0.75, 250, (25-5)//2, fill = 'black', opacity = 75)

    drawLabel("User Bee x 1", app.width*0.75-100, 100, size = 24,fill='black')
    drawLabel("Helper Bee x 2", app.width*0.75-100, 150, size = 24,fill='black')
    drawLabel("Flowers x n", app.width*0.75-100, 200, size = 24,fill='black')
    drawLabel("Need Polly x n", app.width*0.75-100, 250, size = 24,fill='black')
    drawLabel("Use your mouse to control the bee", app.width//2-120, 100, size = 24,fill='darkRed')
    drawLabel("Press 'h' and 'j' to call helper bees", app.width//2-120, 150, size = 24,fill='darkRed')
    drawLabel("Get pollens from flowers", app.width//2-100, 200, size = 24,fill='darkRed')
    drawLabel("Deliver to these flowers", app.width//2-100, 250, size = 24,fill='darkRed')

    



def instruction_onKeyPress(app, key):
    if key == 'space':
        setActiveScreen('game')
        game_restart(app)
def instruction_onMousePress(app, mouseX, mouseY):
    # This is called when the user presses the mouse.
    # For this example, we just have to update the
    # model to move the dot to this location:
    if ((mouseX-200)**2 + (mouseY-300)**2)**0.5 <= 50:
        setActiveScreen('game')
        game_restart(app)

#---------------------------------------------------

# Your screen names should be strings
runAppWithScreens(initialScreen='welcome',width=1000, height=500)
